
# 回溯搜索的模板

def backtrack(待搜索的集合, 递归到第几层, 状态变量 1, 状态变量 2, 结果集):
    # 写递归函数都是这个套路：先写递归终止条件
    if 可能是层数够深了:
        # 打印或者把当前状态添加到结果集中
        return


    for 可以执行的分支路径 do

        # 剪枝
        if 递归到第几层, 状态变量 1, 状态变量 2, 符合一定的剪枝条件:
            continue
        对状态变量状态变量 1, 状态变量 2 的操作（#）
        # 递归执行下一层的逻辑
        backtrack(待搜索的集合, 递归到第几层, 状态变量 1, 状态变量 2, 结果集):
        对状态变量状态变量 1, 状态变量 2 的操作（与标注了 # 的那一行对称，称为状态重置）
    end for

